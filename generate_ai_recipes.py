import os
import json
import time
import re
import google.generativeai as genai
from google.generativeai import configure, GenerativeModel
from google.api_core import exceptions as google_exceptions

# Configure the Gemini API client
GEMINI_API_KEY = "AIzaSyAFUiX-HnUyjFm4-YfaNyboORZeLx6HlSc" # Replace with your actual API key
configure(api_key=GEMINI_API_KEY)

MODEL_NAME = "gemini-1.5-flash" # Using a known and available Gemini model
MOODS = [
    "Comforting", "Adventurous", "Quick & Easy", "Healthy", "Celebratory", "Romantic", "Spicy", "Lazy Sunday",
    "Workout Fuel", "Kid-Friendly", "Fancy Dinner", "Budget", "Hangover Cure", "Impress a Date", "Potluck Dish",
    "Grilling Time", "Baking Day", "Late Night", "Breakfast", "Gloomy Day", "Post-Breakup", "Movie Night",
    "Study Session", "Light & Fresh"
]
RECIPES_PER_MOOD = 10
OUTPUT_FILE = "ai_recipes_by_mood_gemini.md"

def generate_recipe(mood):
    """Generates a recipe for a given mood using the Gemini API with retry logic."""
    prompt = f'''Generate a unique, creative recipe for the mood: "{mood}". 
    Respond ONLY with a valid JSON object with the following fields: 
    title, description, cuisine, servings, prep_time, cook_time, total_time, difficulty, ingredients (array of strings), instructions (array of strings).
    Do not include any other text or markdown formatting like ```json.
    '''
    
    model = GenerativeModel(MODEL_NAME)
    
    retries = 3
    delay = 5  # Start with a 5-second delay for the first retry

    for attempt in range(retries):
        try:
            response = model.generate_content(
                prompt,
                generation_config={
                    "response_mime_type": "application/json",
                }
            )
            return json.loads(response.text)

        except google_exceptions.ResourceExhausted as e:
            if attempt < retries - 1:
                print(f"    [!] Rate limited. Retrying in {delay} seconds... (Attempt {attempt + 1}/{retries})")
                time.sleep(delay)
                delay *= 2  # Double the delay for the next attempt
            else:
                print(f"    [!] Max retries exceeded for rate-limiting.")
                return {"error": "Max retries exceeded due to rate limiting."}

        except Exception as e:
            print(f"    [!] An unexpected error occurred: {e}")
            return {"error": str(e)}
    
    return {"error": "Max retries exceeded."}

def main():
    """Main function to generate recipes and write them to a Markdown file."""
    # --- API Key Pre-flight Check ---
    try:
        print("Checking Gemini API key by listing available models...")
        models_found = any('generateContent' in m.supported_generation_methods for m in genai.list_models())
        if not models_found:
            print("[ERROR] No models found that support 'generateContent'. Check your API key and project permissions.")
            return
        print("API key seems valid. Starting recipe generation...")
    except Exception as e:
        print(f"[ERROR] Failed to connect to Google AI. Please check your API key and network connection. Details: {e}")
        return
    # --------------------------------

    # --- Read existing recipes to allow for resuming ---
    existing_recipes = {}
    if os.path.exists(OUTPUT_FILE):
        print(f"Found existing output file '{OUTPUT_FILE}'. Reading to resume generation.")
        with open(OUTPUT_FILE, "r", encoding="utf-8") as f:
            content = f.read()
        
        mood_sections = re.split(r'\\n## Mood: ', content)
        for section in mood_sections:
            if not section.strip():
                continue
            
            mood_match = re.match(r'([^\\n]+)', section)
            if not mood_match:
                continue
            
            current_mood = mood_match.group(1).strip()
            
            # Find all successful recipe markdown blocks under this mood
            recipe_blocks = re.findall(r'(### Recipe: (?!\\\[Generation Failed\\\])[\\s\\S]*?)(?=\\n### Recipe:|\\n## Mood:|$)', section)
            if recipe_blocks:
                existing_recipes[current_mood] = [block[0].strip() for block in recipe_blocks]

        print("--- Resume Summary ---")
        for mood, recipes in existing_recipes.items():
            if recipes:
                 print(f"  - Found {len(recipes)} existing recipes for '{mood}'.")
        print("--------------------")

    md = "# AI Recipes by Mood (Generated by Gemini)\\n\\n"
    total_recipes = len(MOODS) * RECIPES_PER_MOOD
    current_recipe_count = sum(len(recipes) for recipes in existing_recipes.values())

    for mood in MOODS:
        md += f"## Mood: {mood}\\n\\n"

        # Add existing recipes to the markdown first
        if mood in existing_recipes:
            for recipe_md in existing_recipes[mood]:
                md += recipe_md + "\\n\\n"
        
        num_existing = len(existing_recipes.get(mood, []))
        recipes_to_generate = RECIPES_PER_MOOD - num_existing

        if recipes_to_generate <= 0:
            print(f"Skipping mood '{mood}', as it already has {num_existing} recipes.")
            continue
        
        print(f"Generating {recipes_to_generate} new recipe(s) for mood '{mood}'.")

        for i in range(recipes_to_generate):
            current_recipe_count += 1
            print(f"  -> Generating recipe {i+1}/{recipes_to_generate} for '{mood}' (Overall progress: {current_recipe_count}/{total_recipes})...")
            
            recipe = generate_recipe(mood)
            
            if recipe and not recipe.get("error"):
                recipe_md = f"### Recipe: {recipe.get('title', 'Untitled')}\\n"
                recipe_md += f"- Description: {recipe.get('description', '')}\\n"
                recipe_md += f"- Cuisine: {recipe.get('cuisine', '')}\\n"
                recipe_md += f"- Servings: {recipe.get('servings', '')}\\n"
                recipe_md += f"- Prep Time: {recipe.get('prep_time', '')}\\n"
                recipe_md += f"- Cook Time: {recipe.get('cook_time', '')}\\n"
                recipe_md += f"- Total Time: {recipe.get('total_time', '')}\\n"
                recipe_md += f"- Difficulty: {recipe.get('difficulty', '')}\\n"
                recipe_md += "- Ingredients:\\n"
                for ing in recipe.get("ingredients", []):
                    recipe_md += f"  - {ing}\\n"
                recipe_md += "- Instructions:\\n"
                for idx, step in enumerate(recipe.get("instructions", []), 1):
                    recipe_md += f"  {idx}. {step}\\n"
                md += recipe_md + "\\n"
            else:
                error_message = recipe.get('error') if recipe else 'Unknown error'
                print(f"  [Warning] Generation failed for mood '{mood}' recipe {i+1}: {error_message}")
                md += "### Recipe: [Generation Failed]\\n\\n"
            
            # Add a slightly longer delay to be respectful of the API limits
            time.sleep(3)

    with open(OUTPUT_FILE, "w", encoding="utf-8") as f:
        f.write(md)
        
    # Recalculate final count from the generated markdown string
    final_count = len(re.findall(r'### Recipe: (?!\\\[Generation Failed\\\])', md))
    print(f"\\nSuccessfully exported {final_count}/{total_recipes} recipes to {OUTPUT_FILE}")

if __name__ == "__main__":
    main()

